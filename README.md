# bob-bot

A real-time chatroom with a simple reply bot for the Everchron code challenge

## Instructions for use

Enter anything to see a response from Bob. Start your message "@bob " to send a private message to Bob. Start your message "@User123 " or just "@123 " to send a private message to another user.

## Installation

Prerequisites: Ruby v2.2.2, Bundler, Node/iojs, npm & a running PostgreSQL server.

```
git clone https://github.com/debrisapron/bob_bot.git
cd bob_bot
bundle
bundle exec rake db:setup
npm install
```

## Bob

Bob himself was pretty easy to implement. You can see his tests in `spec/models/bob_spec.rb` and run them with `bundle exec rspec spec/models/bob_spec.rb`. The Bob class is at `app/models/bob.rb`. Because no precedence rules were defined in the original description, I've decided that an all-caps question prompts the responses for both all-caps messages and questions. Also, all-caps is defined as a message containing any unicode upper-case characters but no lower-case ones.

## The chatroom

So this project ended up taking a lot longer than it needed to due to a number of self-imposed obstacles. I decided that since I was going to be spending a few days on this I might as well make it a learning experience by using a number of new (to me) technologies I've been wanting to try out. Specifically:

- True realtime websocket-based pub/sub with Faye
- All-JavaScript SPA with Mithril.js
- Browser testing with Capybara

Obviously it would have been easier to write a traditional Rails app that polled the server every second over XHR for fragments of HTML, but my feeling was that I wouldn't write code like that in the "real world" so I didn't want to write that here.

### Disaster in Capybaraland

Overall this worked out well and I now feel pretty confident with both Faye and Mithril, however Capybara was a total washout. I'm sure that for many projects it works beautifully, however getting Capybara to play nicely with Faye was an epic three-day yak-shave that ended in total failure. I tried every Capybara JS adapter available, I tried running the webserver in a different thread, in a different process, running Faye in a different process, runnning the Node version of Faye, nothing worked. So in the end I gave up and did the browser testing with Nightwatch.js which worked beautifully.

### The API

The rails app is basically just a JSON API, serving the SPA out of its public directory - I could actually have used `rails-api` to eliminate a bunch of extra dependencies. The JSON is serialized with the `active_model_serializers` gem, the serializers are in `app/serializers`. Running the server is just `rails s` and Thin will start on port 3000. There are rspec unit tests and request tests for the API in `spec` which you can run with `bundle exec rspec`.

### Faye

The realtime communication is achieved with Faye running as an in-process Rack middleware and communicating with the SPA via websockets. You can see where it's inserted in the middleware chain in `config/application.rb`. I would have liked to have exercised Faye in my request tests, however that proved technically impossible so I just relied on the browser tests. You can see where I publish the actual Faye events in `app/models/messages/message.rb` and where I subscribe to them in `app/assets/javascripts/message.services.js`.

### The SPA

The SPA is written in Mithril.js, organised as CommonJS modules which are assembled with their dependencies using Browserify. All the JS is in `app/assets/javascripts` and you can build it to `public/assets` by running `npm run build`. The nightwatch browser tests are run with `npm run nightwatch`. Note that they will automatically start and stop a test rails server for you. Also, they don't seem to work if you have the dev rails server running - not sure why since they run the tests on a different port.

### Corners cut

I already spent quite a bit of time on this so I cut a few corners. Some things I didn't do/think about which I would in a production app:

- Documentation. I would add RDoc comments to every model public method, every controller route and anything unusual or interesting. Same with JSDoc in the JavaScript.
- Separate servers. In production I would probably have the rails API, the SPA and the Faye server on different servers, proxied into one domain with NGINX as a frontend to obviate the need for CORS.
- Security. Whilst the token generated by hashids is supposed to be uncrackable, if you had access to someone's machine you could steal the token from their browser `localStorage` and use it to impersonate them forever (since they never expire). There's probably other holes I haven't thought of too.
- I didn't bother with compressing/concatenating my CSS. Bootstrap is just coming from the CDN.
- The interface isn't the most beautiful thing in the world.
